{"meta":{"title":"Brady Z","subtitle":"+1 S","description":"naturezhm 张明 zhm zhangming blog","author":"BradyZ","url":"http://naturezhm.github.io"},"pages":[{"title":"关于我","date":"2016-04-16T05:49:56.000Z","updated":"2016-08-26T10:51:16.500Z","comments":true,"path":"about/index.html","permalink":"http://naturezhm.github.io/about/index.html","excerpt":"","text":"哦，刚才你问我啊，我可以回答一句无可奉告！"}],"posts":[{"title":"做局高手","slug":"做局高手","date":"2016-09-07T02:17:41.000Z","updated":"2016-09-07T03:50:25.468Z","comments":true,"path":"2016/09/07/做局高手/","link":"","permalink":"http://naturezhm.github.io/2016/09/07/做局高手/","excerpt":"","text":"这是一部商界大佬空手套白狼的故事看完此书，让我想起了小武哥曾经说的的这样一段话： 去年有位前辈问我金融的本质是什么，我回头答：流通，我的合伙人回答：获利，前辈说：增信。简短的对话恍然大悟，增信是金融的本质，信是人和人之间交流最值钱的本质，从此立“信”一字为个人和团队价值观，每次接触都努力做到增信，增信从最基本的承诺兑现开始。期间也写过三篇文章来深度理解信，或许今天看不会有任何价值，或许理解有三个层面，表面层，理论层和本质层，以后多年后，来看今天的信的初心，才看到被埋在理论土壤和表象沙子掩埋下的本质的金子。信，值得一生探索未知和深度认知。——小武哥 简介摘自豆瓣书评，可以大致了解这本书题材，读者评价等基本信息。 笔记孟秋时节的一个周末，在图书馆翻阅到此书，本想泛泛而阅，却不料被作者讲故事的手法和创意吸引到了，这本小说的戏剧性其实很明显，极具色彩化的人物及心里描绘，轻而易举到手的资金，让人有种看商战连续剧的感觉，不过此书的灵魂在于思考，思考着圈子的组成、资源的整合、内心的追求、他人的诉求，人心亦善亦恶，有时候善恶往往在一念之间。首先书名也还不错，咋一看有如《如来神掌》般吸睛，然后看到主角登场——丘云鹏？！原谅我，看的时候满脑子都是他不过我觉得能够在商界玩空手道的，怎么着也不会这么猥琐，且不说玉树临风，至少也是气宇轩昂的吧； 丘云鹏，一个在南方破产的商人来到京城孤注一掷，怀揣着仅有的三万元现金和自己的智慧，布下一个大局，在海南破产前，除了落下一屁股债，还落了些虚名头衔，这些名头说无用，确实没什么含金量，亦可说有用，因为正式这些虚名，让他在北京大展拳脚；手里仅仅三万元的他，却要号称自己有了好几十亿，赚钱已经不是目的，振兴文化产业才是个人目标，然后从北京的文化圈，商圈，电视台，甚至官界都抛下一个一个圈套，圈住了对方的同时也套住了自己，一个个承诺和方案，说的他自己都快信了。 人在这个世界上要活的潇洒，就要学会预支一切 这是书中的主体思想之一，预支的前提是自己的信心加上别人的贪心；人一旦有了欲望和贪心，就容易被别人套住，而套住别人的同时也套住了自己。 人有两个弱点，一个是贪心，一个是对自己的怀疑。 这是此书的第二个思想，可以说整部小说都是基于这个思想，其实生活又何尝不是呢？天下熙熙，皆为利来； 天下壤壤， 皆为利往。 虽然是商界小说，但实际上写的却是人心。 作者 @Brady2016年9月7日","categories":[{"name":"读书","slug":"读书","permalink":"http://naturezhm.github.io/categories/读书/"},{"name":"做局高手","slug":"读书/做局高手","permalink":"http://naturezhm.github.io/categories/读书/做局高手/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://naturezhm.github.io/tags/读书/"},{"name":"做局高手","slug":"做局高手","permalink":"http://naturezhm.github.io/tags/做局高手/"},{"name":"柯云路","slug":"柯云路","permalink":"http://naturezhm.github.io/tags/柯云路/"}],"keywords":[{"name":"读书","slug":"读书","permalink":"http://naturezhm.github.io/categories/读书/"},{"name":"做局高手","slug":"读书/做局高手","permalink":"http://naturezhm.github.io/categories/读书/做局高手/"}]},{"title":"03-循环依赖","slug":"03-循环依赖","date":"2016-08-30T02:56:39.000Z","updated":"2016-08-30T09:31:17.119Z","comments":true,"path":"2016/08/30/03-循环依赖/","link":"","permalink":"http://naturezhm.github.io/2016/08/30/03-循环依赖/","excerpt":"","text":"实例化bean是一个比较复杂的过程，在factory构造对象后，还要进行初始化，这其中就包括了依赖检测和循环依赖的解决。 1. 什么是循环依赖循环依赖即环状引用，两个或者以上bean相互持有对方的引用，变成一个环状。 2. Spring是如何解决的 构造循环依赖这类依赖是无法解决的，只能抛出BeanCurrentlyInCreationException setter循环依赖表示通过setter注入方式构成的循环依赖，Spring仅能解决单例的循环依赖，因为Spring会提前构建和缓存好单例的bean实例，而其他模式不会。具体流程如下图所示： 作者 @Brady2016年8月10日","categories":[{"name":"框架","slug":"框架","permalink":"http://naturezhm.github.io/categories/框架/"},{"name":"Spring源码学习","slug":"框架/Spring源码学习","permalink":"http://naturezhm.github.io/categories/框架/Spring源码学习/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://naturezhm.github.io/tags/分布式/"},{"name":"Spring源码","slug":"Spring源码","permalink":"http://naturezhm.github.io/tags/Spring源码/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://naturezhm.github.io/categories/框架/"},{"name":"Spring源码学习","slug":"框架/Spring源码学习","permalink":"http://naturezhm.github.io/categories/框架/Spring源码学习/"}]},{"title":"02-创建器","slug":"02-创建器","date":"2016-08-27T09:03:53.000Z","updated":"2016-08-30T03:02:02.830Z","comments":true,"path":"2016/08/27/02-创建器/","link":"","permalink":"http://naturezhm.github.io/2016/08/27/02-创建器/","excerpt":"","text":"1. 构造工厂DefaultListableBeanFactoryXmlBeanFactory继承自DefaultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是默认实现，介绍下类图中的各个类的作用： （接口）AliasRegistry：定义对alias的简单增删改等操作； （类）SimpleAliasRegistry：主要使用map作为alias的缓存，并对接口AliasRegistry进行实现； （接口）SingletonBeanRegistry：定义对单例的注册及获取； （接口）BeanFactory：定义获取bean及bean的各种属性； （类）DefaultSingletonBeanRegistry：默认实现； （接口）HierarchicalBeanFactory：继承BeanFactory，也就是在BeanFactory定义的功能的基础上增加了对parentFactory的支持； （接口）BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作； （抽象类）FactoryBeanRegistrySupport：在DefaultSingletonBeanRegistry的基础上增加了对FactoryBean的特殊处理； （接口）ConfigurableBeanFactory：提供配置Factory的各种方法； （接口）ListableBeanFactory：根据各种条件获取bean的配置清单； （抽象类）AbstractBeanFactory：综合了ConfigurableBeanFactory和FactoryBeanRegistrySupport的功能； （接口）AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器； （抽象类）AbstractAutowireCapableBeanFactory：综合了AutowireCapableBeanFactory和AbstractBeanFactory的实现； （接口）ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等； （类）DefaultListableBeanFactory：综合上面的类和接口，主要增加了对bean注册后的处理。 2. 配置文件读取和解析XmlBeanDefinitionReader在使用XML配置式的Spring项目中，会用到这个XmlBeanDefinitionReader，包含了以下处理： 通过继承抽象类AbstractBeanDefinitionReader中的方法，使用ResourcesLoader将资源文件路径转换为对应的Resource文件； 通过DocumentLoader对Resource文件进行转换，讲Resource文件转换为Document文件； 通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegete对Element进行解析。 3. 配置解析构造流程解析在main方法中写下如下代码1BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"beansTest.xml\")); 其执行逻辑为： 4. Resource封装在java中不同资源文件有着URL作为抽象，但是不太实用，URL没有一些基本方法，比如检查是否存在，是否可读写，等，而spring则使用的自己封装的Resource来代表资源，类图如下 5. 实例化Bean总体步骤其实很简单： 获取对XML文件的验证模式（DTD或者XSD）； 加载XML文件，返回Document对象； 根据Document对象实例化bean。 真正解析的方法为DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(Element root)详细步骤如下：1、转换对于beaName。传入的name或者别名等，进行解析和转换，去除修饰符；2、尝试从缓存中加载单例；ps: 单例只会创建一次，spring会将ObjectFactory先创建到缓存中，再创建bean到缓存中；3、bean的实例化，如果从缓存中得到bean的原始状态，则需要对bean进行实例化；4、原型模式的依赖检查；5、检测parentBeanFactory；6、将存储文件的GenericBeanDefinition转换为RootBeanDefinition；7、寻找依赖；8、针对不同的scope进行bean的创建；9、类型转换； 作者 @Brady2016年8月10日","categories":[{"name":"框架","slug":"框架","permalink":"http://naturezhm.github.io/categories/框架/"},{"name":"Spring源码学习","slug":"框架/Spring源码学习","permalink":"http://naturezhm.github.io/categories/框架/Spring源码学习/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://naturezhm.github.io/tags/分布式/"},{"name":"Spring源码","slug":"Spring源码","permalink":"http://naturezhm.github.io/tags/Spring源码/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://naturezhm.github.io/categories/框架/"},{"name":"Spring源码学习","slug":"框架/Spring源码学习","permalink":"http://naturezhm.github.io/categories/框架/Spring源码学习/"}]},{"title":"倾城之恋","slug":"倾城之恋","date":"2016-08-26T04:22:38.000Z","updated":"2016-08-27T03:47:32.906Z","comments":true,"path":"2016/08/26/倾城之恋/","link":"","permalink":"http://naturezhm.github.io/2016/08/26/倾城之恋/","excerpt":"","text":"没错，我不仅看书，还要开始写读后感了 人终其一生只能活一次，而在书籍，小说，电影，他人的分享中我们获得了重生，每一次阅读新的书籍，看新的小说，电影，电视剧都是自我人生的重新开始。打开书本的那一刻，是漂泊在过去，现在，未来的灵魂。爱恨情仇，生离死别扑面而来，让人措手不及。 本书简介以下摘自豆瓣书评，可以大致了解这本书题材，读者评价等基本信息。 在一位朋友的推荐下，第一次认真拜读张爱玲的著作，《倾城之恋》应该算她比较典型的作品之一了，文笔自不用说，没有华丽辞藻来修饰，而是朴实的将一个个角色的灵魂, 智慧, 善良, 包容, 炫耀, 做作，矫情，矜持等等心性暴露出来，果大师之作，就是能直击内心。 首先“倾城之恋”这个书名就非常好，在看之前我就想着主人公应该会有这倾国倾城的美貌吧，也有可能会很悲壮，像孟姜女哭倒长城一样，也算倾了城；后来看了才知道，这原来是一个自私的男人和一个自私的女人产生了真爱的故事，真爱的产生正是因为倾了城——香港的沦陷，书名由来可能也是于此；其实想想，不仅是在那个兵荒马乱的年代，就是当下，真爱依然难寻，试问真爱值几钱？再说下去，就是扯物质、精神、境界、人生观、价值观上了，其实扯来扯去，任何时代，相亲无非是男女在做天平的平衡匹配，各自抛出自己的一个个砝码，抛到最后，发现还是平衡的，这个事差不多就成了，年代不同，砝码的重量不一样而已。回到小说中的年代，上海仍然被殖民，具体年代我也不清楚； 范柳原，一个海外归来的浪子，生活的纸醉金迷，便把“女人看成他脚底下的泥”，爱情和婚姻原是他不相信，也不敢指望的。但他内心深处是渴望安稳的，对待女主也起初只是想养一个情妇而已。 白流苏，一个离过婚的女人，出身守旧的白家，白公馆的老钟在最开始就是一个交代，和男主交往也是只求一个完美的婚姻，一张长久的饭票。 就这样他们勾搭上了，各怀鬼胎，相互试探，这部分爱情攻防战是小说很精彩的部分，我估计如果是现实，剧情就在这里停止了，既然是小说，总要有个难忘的结局吧，所以炮火响起了，香港沦陷了，尔虞我诈的计较在失去一切之后发现身边仅有你我时，俩人傻子一样大笑起来，真爱也就滋生了，男主也认真的恋爱了，女主也心满意足了。 范柳原最后又说了一遍，“现在你可该相信了：‘死生契阔’，我们自己哪做得了主？……”，其实这里我觉得，不仅是“死生契阔”我们做不了主，就连爱情里的求全责备，权衡算计也是做不了主的。 作者 @Brady2016年8月26日","categories":[{"name":"读书","slug":"读书","permalink":"http://naturezhm.github.io/categories/读书/"},{"name":"倾城之恋","slug":"读书/倾城之恋","permalink":"http://naturezhm.github.io/categories/读书/倾城之恋/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://naturezhm.github.io/tags/读书/"},{"name":"倾城之恋","slug":"倾城之恋","permalink":"http://naturezhm.github.io/tags/倾城之恋/"},{"name":"张爱玲","slug":"张爱玲","permalink":"http://naturezhm.github.io/tags/张爱玲/"}],"keywords":[{"name":"读书","slug":"读书","permalink":"http://naturezhm.github.io/categories/读书/"},{"name":"倾城之恋","slug":"读书/倾城之恋","permalink":"http://naturezhm.github.io/categories/读书/倾城之恋/"}]},{"title":"01-Spring整体架构","slug":"01-Spring整体架构","date":"2016-08-10T08:37:45.000Z","updated":"2016-08-30T09:35:41.297Z","comments":true,"path":"2016/08/10/01-Spring整体架构/","link":"","permalink":"http://naturezhm.github.io/2016/08/10/01-Spring整体架构/","excerpt":"","text":"开坑前言作为一个开发者，阅读源码是一种非常好的学习方式，在我们日常工作或者学习中，或多或少会接触到一些开源代码，例如Java中的SSH, mybatis等，这些源码的普及和应用程度远远超过我们的想象，很多人也不断的推动和完善这些代码，有着多年积淀，不管我们当前是什么水平，阅读这些源码可以更加熟练使用，让我们程序设计更加完美，让我们思维方式更为开阔，纵观身边的朋友，能够通读源码的人确实不多，究其原因，无外乎： 时间精力有限，不愿意开始着手； 复杂度太高了，面对庞大的环环相扣的源码体系，无从下手，无法驾驭； 耐心或者说毅力不够，以为自己能见微知著，殊不知却是盲人摸象。 无论基于什么情况，放弃对源码的阅读始终难免留下遗憾，因为失去了和大师学习的机会，而且是自己亲手放弃的。开这个坑，也是计划通过博客记录，做出经验沉淀，不为传授，只为记录，在开始阅读时，我选择了几本书作为辅助工具，辅佐我作为一个源码阅读的入口，因为面对好几个MB的源码，我也照样无从下手。 1 Spring的整体架构如下图所示，spring框架包含很多功能集合，约20个模块这些模块分别为： (1) Core container核心容器，包括了Core, Beans, Context和Expression Language模块。 Core和Beans模块是框架的基础部分，提供了Ioc和DI特性，这里的基础概念是BeanFactory，他提供对Factory模式的实现来消除程序单例模式的需要，并真正的让程序逻辑中分离出依赖关系和配置。 Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件都要使用这个包； Beans模块是所有应用都要用到的，包含访问配置文件、创建和管理bean以及进行IoC/DI操作相关的类。 Context模块构建与Core与Beans之上，提供了一种类似与JNDI注册器的框架式对象访问方法，Context继承Beans特性，为Spring核心提供了大量的扩展，添加了对国际化、事件传播、资源加载核对Context的透明创建支持，支持J2EE的一些特性，EJB,JMX和基础的远程处理，其中ApplicationContext是Context模块的关键。 Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操作对象，扩展了JSP expression language。 (2) Data access/IntegrationData access/Integration层包含了JDBC、ORM、OXM、JMS和Transation模块，其中： JDBC模块提供了一个JDBC抽象层，对各类数据库进行了封装； ORM模块熟悉的有Hibernate、Mybatis提供了一个数据访问层。 OXM框架提供了一个对Object/XML映射实现的抽象层，Object/XML映射实现包括JAXB、Castor、XMLBeans、JiBx、Xstream。（其实我觉得Object/Json方式比OXM更好） JMS主要包含了一些制造和消费消息的特性； Transation模块支持编程和声明性事物的管理，这些事物类必须实现特定的接口，并且对所有的POJO都使用。 (3) WebWeb模块是简历在Servlet程序模块之上，Spring兹慈与其他文本框架Struts的集成，Web模块还简化了处理多中请求及参数绑定的工作；好汉了Web、Web-Servlet、Web-struts和Web-Prolet模块，具体说明如下： Web模块：提供了基础的面向Web的集成特性，例如，多文件上传，使用servlet listeners初始化Ioc容器以及一个面向web的应用上下文； Web-Servlet模块：该模块包含Spring的MVC实现，使得模型范围内的代码和web form之间能够清晰的分开并能与Spring框架的其他特性集成在一起； Web-Struts模块：提供了对struts的兹慈，但是在3.0后已经deprecated了。 Web-Porlet模块：提供了Porlet环境和Web-Servlet模块的MVC实现（在需要写Porlet应用时可以直接用这个模块，不过在如今各类webservice当道的情况下，RSS都比较少见了，貌似一般不会选型这个）。 (4) AOPAOP模块提供了一个符合标准的面向切面编程实现，可以降低耦合性，利用Source-level的注解机制（元数据功能），还可以讲各种行为信息整合到代码里，类似.net中的attribute（不是parameter）；Spring AOP提供了事物管理服务， (5) TestTest模块支持各种测试框架。 作者 @Brady2016年8月10日","categories":[{"name":"框架","slug":"框架","permalink":"http://naturezhm.github.io/categories/框架/"},{"name":"Spring源码学习","slug":"框架/Spring源码学习","permalink":"http://naturezhm.github.io/categories/框架/Spring源码学习/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://naturezhm.github.io/tags/分布式/"},{"name":"Spring源码","slug":"Spring源码","permalink":"http://naturezhm.github.io/tags/Spring源码/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://naturezhm.github.io/categories/框架/"},{"name":"Spring源码学习","slug":"框架/Spring源码学习","permalink":"http://naturezhm.github.io/categories/框架/Spring源码学习/"}]},{"title":"ZMQ详细安装文档","slug":"ZMQ详细安装文档","date":"2016-07-16T08:23:39.000Z","updated":"2016-08-26T10:07:43.839Z","comments":true,"path":"2016/07/16/ZMQ详细安装文档/","link":"","permalink":"http://naturezhm.github.io/2016/07/16/ZMQ详细安装文档/","excerpt":"","text":"1. JDK安装我安装的是java version “1.8.0_73”注意： 要配置好classpath，检测方法为1234567###如果结果如下，表示配置成功[root@server001 java]# java -versionjava version \"1.8.0_73\"Java(TM) SE Runtime Environment (build 1.8.0_73-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)[root@server001 java]# javac -versionjavac 1.8.0_73 2. 官网下载zeromq的源码https://github.com/zeromq/zeromq4-1/releases/download/v4.1.5/zeromq-4.1.5.tar.gz或者我共享的zip压缩包@gitoschina 3. 解压，编译安装zeromqs 检查环境 1sudo yum install autoconf automake libtool gcc gcc-g++ make libuuid-dev git 安装指令如下(make install 指令需要root权限)12345678tar -xzf zeromq-4.1.5.tar.gz cd zeromq-4.1.5./autogen.sh./configuremakemake installldconfig## 安装完成后，如果没报错，ls /usr/local/lib 会发现有文件名为libzmq的文件表示安装成功 4. 下载JZMQJZMQ是java封装了一下ZMQ，不是另外一个Pure Java ZeroMQ，下载地址为https://github.com/zeromq/jzmq.git，用git clone下来或者下载zip压缩包@github或者我共享的zip压缩包@gitoschina 不要下载v3.1.0 release版本，这个无法编译，是坑 5. 解压编译安装JZMQ 安装指令如下(make install指令需要root权限)12345678unzip jzmq-master.zipcd jzmq-jni/./autogen.sh./configuremakemake install### cd ..### mvn package 官网有这个步骤，但是别按着来，是坑 安装完成后检查，如果都符合，恭喜，很有可能安装成功123456789#### lib下有如下包[root@server001 java]# ls /usr/local/liblibjzmq.a libjzmq.so.0 libpcre2-8.la libpcre2-8.so.0.3.0 libpcre2-posix.so libz.a libzmq.so libz.so pkgconfiglibjzmq.la libjzmq.so.0.0.0 libpcre2-8.so libpcre2-posix.a libpcre2-posix.so.0 libzmq.a libzmq.so.5 libz.so.1libjzmq.so libpcre2-8.a libpcre2-8.so.0 libpcre2-posix.la libpcre2-posix.so.0.0.1 libzmq.la libzmq.so.5.0.1 libz.so.1.2.8#### 有jar包在此目录[root@server001 lib]# ls /usr/local/share/java/zmq.jar 设置环境变量（root权限）1234567vi /etc/bashrcvi /etc/profile### 底部添加如下内容LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/libexport LD_LIBRARY_PATHCLASSPATH=.:$CLASSPATH:/usr/local/share/java/zmq.jarexport CLASSPATH 6. 写server和client代码验证JZMQ安装成功这里是官方的Guide文档（很长，有多种语言的实现，我们只选择Java）http://zguide.zeromq.org/page:all你也可以看我写的代码进行测试123456789101112131415161718### 运行成功输出[root@server001 java]# java -jar server.jar Received HelloReceived HelloReceived HelloReceived Hello...[root@server001 java]# java -jar client.jar Connecting to hello world server…Sending Hello 0Received World 0Sending Hello 1Received World 1Sending Hello 2Received World 2... 以下是测试Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.zeromq.ZMQ;/** * Created by admin on 2016/7/15. */public class hwserver &#123; public static void main(String[] args) throws InterruptedException &#123; ZMQ.Context context = ZMQ.context(1); // Socket to talk to clients ZMQ.Socket responder = context.socket(ZMQ.REP); responder.bind(\"tcp://*:5555\"); while (!Thread.currentThread().isInterrupted()) &#123; // Wait for next request from the client byte[] request = responder.recv(0); System.out.println(\"Received Hello\"); // Do some 'work' Thread.sleep(1000); // Send reply back to client String reply = \"World\"; responder.send(reply.getBytes(), 0); &#125; responder.close(); context.term(); &#125;&#125;import org.zeromq.ZMQ;/** * Created by admin on 2016/7/15. */public class hwclient &#123; public static void main(String[] args) &#123; ZMQ.Context context = ZMQ.context(1); // Socket to talk to server System.out.println(\"Connecting to hello world server…\"); ZMQ.Socket requester = context.socket(ZMQ.REQ); requester.connect(\"tcp://localhost:5555\"); for (int requestNbr = 0; requestNbr != 10; requestNbr++) &#123; String request = \"Hello\"; System.out.println(\"Sending Hello \" + requestNbr); requester.send(request.getBytes(), 0); byte[] reply = requester.recv(0); System.out.println(\"Received \" + new String(reply) + \" \" + requestNbr); &#125; requester.close(); context.&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://naturezhm.github.io/categories/编程/"},{"name":"消息队列","slug":"编程/消息队列","permalink":"http://naturezhm.github.io/categories/编程/消息队列/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://naturezhm.github.io/tags/分布式/"},{"name":"消息队列","slug":"消息队列","permalink":"http://naturezhm.github.io/tags/消息队列/"},{"name":"JZMQ","slug":"JZMQ","permalink":"http://naturezhm.github.io/tags/JZMQ/"},{"name":"ZMQ","slug":"ZMQ","permalink":"http://naturezhm.github.io/tags/ZMQ/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://naturezhm.github.io/categories/编程/"},{"name":"消息队列","slug":"编程/消息队列","permalink":"http://naturezhm.github.io/categories/编程/消息队列/"}]},{"title":"双端队列(deque)","slug":"双端队列-deque","date":"2013-04-17T03:49:19.000Z","updated":"2016-08-26T08:33:45.256Z","comments":true,"path":"2013/04/17/双端队列-deque/","link":"","permalink":"http://naturezhm.github.io/2013/04/17/双端队列-deque/","excerpt":"","text":"这一篇是很久前第一次写的，其实不算原创，抄了其他人的博客，不过都特别说明了 暑假，今天看到双端队列(deque)了，书上是这样说的： 除了栈和队列外还有一种限定性数据结构是双端队列；双端队列是限定插入和删除操作在表的两端进行的线性表；尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，故在此不作详细讨论。 于是乎就跳了过去讲链队列和循环队列去了，我想反正是复习嘛，没有考试的压力，不要放过就是了，再说就算双端队列远不及栈和队列有用，也要知道怎么个没用法。所以就查了下: Deque成员函数 函数 描述 c.assign(n,elem) 将n个elem的拷贝赋值给c。 c.at(idx) 传回索引idx所指的数据，如果idx越界，抛出out_of_range。 c.back() 传回最后一个数据，不检查这个数据是否存在。 c.begin() 传回迭代器重的可一个数据。 c.clear() 移除容器中所有数据。 deque c 创建一个空的deque。 deque c1(c2) 复制一个deque。 Deque c(n) 创建一个deque，含有n个数据，数据均已缺省构造产生。 Deque c(n, elem) 创建一个含有n个elem拷贝的deque。 Deque c(beg,end) 创建一个以[beg;end)区间的deque。 c.~deque() 销毁所有数据，释放内存。 c.empty() 判断容器是否为空。 c.end() 指向迭代器中的最后一个数据地址。 c.erase(pos) 删除pos位置的数据，传回下一个数据的位置。 c.erase(beg,end) 删除[beg,end)区间的数据，传回下一个数据的位置。 c.front() 传回地一个数据。 get_allocator 使用构造函数返回一个拷贝。 c.insert(pos,elem) 在pos位置插入一个elem拷贝，传回新数据位置。 c.insert(pos,n,elem) 在pos位置插入&gt;n个elem数据。无返回值。 c.insert(pos,beg,end) 在pos位置插入在[beg,end)区间的数据。无返回值。 c.max_size() 返回容器中最大数据的数量。 c.pop_back() 删除最后一个数据。 c.pop_front() 删除头部数据。 c.push_back(elem) 在尾部加入一个数据。 c.push_front(elem) 在头部插入一个数据。 c.rbegin() 传回一个逆向队列的第一个数据。 c.rend() 传回一个逆向队列的最后一个数据的下一个位置。 c.resize(num) 重新指定队列的长度。 c.size() 返回容器中实际数据的个数。 C1.swap(c2) 将c1和c2元素互换。 Swap(c1,c2) 同上操作。 operator[] 返回容器中指定位置的一个引用。 又搜到了一个使用C++ STL容器基本操作的博客 ，后我照着一些简单的程序写了遍，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657双端队列容器(deque)/*2011.7.24使用c++ STL库的双端队列容器(deque)的小程序看了博客 http://hi.baidu.com/xuehuo_0411/blog/item/c225942c0a02033a349bf7d1.html 后照着写的msdn的文档是 http://msdn.microsoft.com/zh-cn/library/bb398188.aspx其中还有些没有写了，其他重要函数d1.swap(d2);//d1和d2交换zm.max_size();//可支持的最大deque元素个数zm.front();//首元素zm.back();//末元素*/#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;iterator&gt;using namespace std;void viewByArrey(deque&lt;int&gt; zm);//用数组的方式访问deque元素void viewByIterator(deque&lt;int&gt; zm);//用迭代器的方式來訪問deque元素void insertFrontAndCenter(deque&lt;int&gt; zm); //头部和中间位置插入deque元素int main()&#123; deque&lt;int&gt; zm; //viewByArrey(zm); //viewByIterator(zm); insertFrontAndCenter(zm);//头部和中间位置插入deque元素 system(\"pause\"); &#125;void viewByArrey(deque&lt;int&gt; zm)&#123;//用数组的方式访问deque元素 zm.push_back(26); zm.push_back(11); zm.push_back(12); for(int i = 0; i &lt; zm.size();i++)&#123; cout&lt;&lt;zm[i]&lt;&lt;endl; &#125; &#125;void viewByIterator(deque&lt;int&gt; zm)&#123; zm.push_back(111); zm.push_back(222); zm.push_back(333); deque&lt;int&gt;::iterator aa;//定义了迭代器aa int i = 0; for(aa = zm.begin(),i = 0;aa != zm.end();aa++,i++)&#123; cout&lt;&lt;aa[0]&lt;&lt;\"\\t\"&lt;&lt;*aa&lt;&lt;endl; //cout&lt;&lt;*aa&lt;&lt;endl; &#125; &#125;void insertFrontAndCenter(deque&lt;int&gt; zm)&#123;//头部和中间位置插入deque元素 zm.push_back(111); zm.push_back(222); zm.push_front(333);//放到前面 zm.insert(zm.begin()+2,444);//理论上是放到111后面 //看是不是这个顺序333,111,444,222 for(int i = 0; i &lt; zm.size();i++)&#123; cout&lt;&lt;zm[i]&lt;&lt;\",\"; &#125; cout&lt;&lt;endl; &#125; 写完之后，觉得deque还是很好用的啊，就查了下“C++ STL deque的缺点”，觉得这人讲的不错，还做了对比，内容不多就贴下吧， 1 vector向量 相当于一个数组 在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。 优点： 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back() 随机访问方便，即支持[ ]操作符和vector.at() 节省空间。缺点： 在内部进行插入删除操作效率低。 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放 2 list双向链表 每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。 优点： 不使用连续内存完成动态操作。 在内部方便的进行插入和删除操作 可在两端进行push、pop 缺点： 不能进行内部的随机访问，即不支持[ ]操作符和vector.at() 相对于verctor占用内存多 3 deque 双端队列 double-end queue deque是在功能上合并了vector和list。 优点： 随机访问方便，即支持[ ]操作符和vector.at() 在内部方便的进行插入和删除操作 可在两端进行push、pop 缺点： 占用内存多 使用区别： 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector 如果你需要大量的插入和删除，而不关心随即存取，则应使用list 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque 看了后觉得deque还是很好用的嘛，虽然内存占用多些，但是也不至于像书上那样说的一无是处，deque像是集vector和list两者特性的一个容器，牺牲内存换的功能的完善也没什么不可以吧。","categories":[{"name":"编程","slug":"编程","permalink":"http://naturezhm.github.io/categories/编程/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"http://naturezhm.github.io/categories/编程/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://naturezhm.github.io/tags/数据结构/"},{"name":"测试","slug":"测试","permalink":"http://naturezhm.github.io/tags/测试/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://naturezhm.github.io/categories/编程/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"http://naturezhm.github.io/categories/编程/数据结构/"}]},{"title":"Hello World","slug":"hello-world","date":"2013-04-01T03:49:19.000Z","updated":"2016-08-26T08:34:11.536Z","comments":true,"path":"2013/04/01/hello-world/","link":"","permalink":"http://naturezhm.github.io/2013/04/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}