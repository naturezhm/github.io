<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brady Z</title>
  <subtitle>+1 S</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://naturezhm.github.io/"/>
  <updated>2016-08-30T09:31:17.119Z</updated>
  <id>http://naturezhm.github.io/</id>
  
  <author>
    <name>BradyZ</name>
    <email>naturezhm@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03-循环依赖</title>
    <link href="http://naturezhm.github.io/2016/08/30/03-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://naturezhm.github.io/2016/08/30/03-循环依赖/</id>
    <published>2016-08-30T02:56:39.000Z</published>
    <updated>2016-08-30T09:31:17.119Z</updated>
    
    <content type="html"><![CDATA[<p>实例化bean是一个比较复杂的过程，在factory构造对象后，还要进行初始化，这其中就包括了依赖检测和循环依赖的解决。</p>
<h2 id="1-什么是循环依赖"><a href="#1-什么是循环依赖" class="headerlink" title="1. 什么是循环依赖"></a>1. 什么是循环依赖</h2><p>循环依赖即环状引用，两个或者以上bean相互持有对方的引用，变成一个环状。</p>
<h2 id="2-Spring是如何解决的"><a href="#2-Spring是如何解决的" class="headerlink" title="2. Spring是如何解决的"></a>2. Spring是如何解决的</h2><ol>
<li><strong>构造循环依赖</strong><br>这类依赖是<strong>无法解决</strong>的，只能抛出<em>BeanCurrentlyInCreationException</em></li>
<li><strong>setter循环依赖</strong><br>表示通过setter注入方式构成的循环依赖，<strong>Spring仅能解决单例的循环依赖</strong>，因为Spring会提前构建和缓存好单例的bean实例，而其他模式不会。具体流程如下图所示：<br><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/Spring%E5%8D%95%E4%BE%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.png?imageView2/1/w/620/h/710/interlace/1/q/100" alt="Spring循环依赖解决"></li>
</ol>
<hr>
<p>作者 <a href="https://github.com/naturezhm" target="_blank" rel="external">@Brady</a><br>2016年8月10日   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实例化bean是一个比较复杂的过程，在factory构造对象后，还要进行初始化，这其中就包括了依赖检测和循环依赖的解决。&lt;/p&gt;
&lt;h2 id=&quot;1-什么是循环依赖&quot;&gt;&lt;a href=&quot;#1-什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是
    
    </summary>
    
      <category term="框架" scheme="http://naturezhm.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring源码学习" scheme="http://naturezhm.github.io/categories/%E6%A1%86%E6%9E%B6/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="分布式" scheme="http://naturezhm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Spring源码" scheme="http://naturezhm.github.io/tags/Spring%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>02-创建器</title>
    <link href="http://naturezhm.github.io/2016/08/27/02-%E5%88%9B%E5%BB%BA%E5%99%A8/"/>
    <id>http://naturezhm.github.io/2016/08/27/02-创建器/</id>
    <published>2016-08-27T09:03:53.000Z</published>
    <updated>2016-08-30T03:02:02.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-构造工厂DefaultListableBeanFactory"><a href="#1-构造工厂DefaultListableBeanFactory" class="headerlink" title="1. 构造工厂DefaultListableBeanFactory"></a>1. 构造工厂DefaultListableBeanFactory</h2><p>XmlBeanFactory继承自DefaultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是默认实现，介绍下类图中的各个类的作用：</p>
<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/DefaultListableBeanFactory.png?imageView2/1/w/1080/h/550/interlace/1/q/100" alt="DefaultListableBeanFactory Class Diagram"></p>
<ul>
<li>（接口）AliasRegistry：定义对alias的简单增删改等操作；</li>
<li>（类）SimpleAliasRegistry：主要使用map作为alias的缓存，并对接口AliasRegistry进行实现；</li>
<li>（接口）SingletonBeanRegistry：定义对单例的注册及获取；</li>
<li>（接口）BeanFactory：定义获取bean及bean的各种属性；</li>
<li>（类）DefaultSingletonBeanRegistry：默认实现；</li>
<li>（接口）HierarchicalBeanFactory：继承BeanFactory，也就是在BeanFactory定义的功能的基础上增加了对parentFactory的支持；</li>
<li>（接口）BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作；</li>
<li>（抽象类）FactoryBeanRegistrySupport：在DefaultSingletonBeanRegistry的基础上增加了对FactoryBean的特殊处理；</li>
<li>（接口）ConfigurableBeanFactory：提供配置Factory的各种方法；</li>
<li>（接口）ListableBeanFactory：根据各种条件获取bean的配置清单；</li>
<li>（抽象类）AbstractBeanFactory：综合了ConfigurableBeanFactory和FactoryBeanRegistrySupport的功能；</li>
<li>（接口）AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器；</li>
<li>（抽象类）AbstractAutowireCapableBeanFactory：综合了AutowireCapableBeanFactory和AbstractBeanFactory的实现；</li>
<li>（接口）ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等；</li>
<li>（类）DefaultListableBeanFactory：综合上面的类和接口，主要增加了对bean注册后的处理。</li>
</ul>
<h2 id="2-配置文件读取和解析XmlBeanDefinitionReader"><a href="#2-配置文件读取和解析XmlBeanDefinitionReader" class="headerlink" title="2. 配置文件读取和解析XmlBeanDefinitionReader"></a>2. 配置文件读取和解析XmlBeanDefinitionReader</h2><p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/XmlBeanDefinitionReader.png" alt="XmlBeanDefinitionReader Class Diagram"><br>在使用XML配置式的Spring项目中，会用到这个XmlBeanDefinitionReader，包含了以下处理：</p>
<ol>
<li>通过继承抽象类AbstractBeanDefinitionReader中的方法，使用ResourcesLoader将资源文件路径转换为对应的Resource文件；</li>
<li>通过DocumentLoader对Resource文件进行转换，讲Resource文件转换为Document文件；</li>
<li>通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegete对Element进行解析。</li>
</ol>
<h2 id="3-配置解析构造流程解析"><a href="#3-配置解析构造流程解析" class="headerlink" title="3. 配置解析构造流程解析"></a>3. 配置解析构造流程解析</h2><p>在main方法中写下如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beansTest.xml"</span>));</div></pre></td></tr></table></figure></p>
<p>其执行逻辑为：</p>
<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/beanfactory%20seq.svg" alt="beanfactory seq"></p>
<h2 id="4-Resource封装"><a href="#4-Resource封装" class="headerlink" title="4. Resource封装"></a>4. Resource封装</h2><p>在java中不同资源文件有着URL作为抽象，但是不太实用，URL没有一些基本方法，比如检查是否存在，是否可读写，等，而spring则使用的自己封装的Resource来代表资源，类图如下</p>
<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/resource%20diagram.png" alt="resource diagram"></p>
<h2 id="5-实例化Bean"><a href="#5-实例化Bean" class="headerlink" title="5. 实例化Bean"></a>5. 实例化Bean</h2><p>总体步骤其实很简单：</p>
<ol>
<li>获取对XML文件的验证模式（DTD或者XSD）；</li>
<li>加载XML文件，返回Document对象；</li>
<li>根据Document对象实例化bean。<blockquote>
<p>真正解析的方法为DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(Element root)<br>详细步骤如下：<br>1、转换对于beaName。传入的name或者别名等，进行解析和转换，去除<br>修饰符；<br>2、尝试从缓存中加载单例；<br>ps: 单例只会创建一次，spring会将ObjectFactory先创建到缓存中，再创建bean到缓存中；<br>3、bean的实例化，如果从缓存中得到bean的原始状态，则需要对bean进行实例化；<br>4、原型模式的依赖检查；<br>5、检测parentBeanFactory；<br>6、将存储文件的GenericBeanDefinition转换为RootBeanDefinition；<br>7、寻找依赖；<br>8、针对不同的scope进行bean的创建；<br>9、类型转换；</p>
</blockquote>
</li>
</ol>
<hr>
<p>作者 <a href="https://github.com/naturezhm" target="_blank" rel="external">@Brady</a><br>2016年8月10日   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-构造工厂DefaultListableBeanFactory&quot;&gt;&lt;a href=&quot;#1-构造工厂DefaultListableBeanFactory&quot; class=&quot;headerlink&quot; title=&quot;1. 构造工厂DefaultListableBeanFa
    
    </summary>
    
      <category term="框架" scheme="http://naturezhm.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring源码学习" scheme="http://naturezhm.github.io/categories/%E6%A1%86%E6%9E%B6/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="分布式" scheme="http://naturezhm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Spring源码" scheme="http://naturezhm.github.io/tags/Spring%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>倾城之恋</title>
    <link href="http://naturezhm.github.io/2016/08/26/%E5%80%BE%E5%9F%8E%E4%B9%8B%E6%81%8B/"/>
    <id>http://naturezhm.github.io/2016/08/26/倾城之恋/</id>
    <published>2016-08-26T04:22:38.000Z</published>
    <updated>2016-08-27T03:47:32.906Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/qinchenzhilian.jpg" alt="倾城之恋"></p>
<h2 id="没错，我不仅看书，还要开始写读后感了"><a href="#没错，我不仅看书，还要开始写读后感了" class="headerlink" title="没错，我不仅看书，还要开始写读后感了"></a>没错，我不仅看书，还要开始写读后感了</h2><blockquote>
<p>人终其一生只能活一次，而在书籍，小说，电影，他人的分享中我们获得了重生，每一次阅读新的书籍，看新的小说，电影，电视剧都是自我人生的重新开始。打开书本的那一刻，是漂泊在过去，现在，未来的灵魂。爱恨情仇，生离死别扑面而来，让人措手不及。</p>
</blockquote>
<h2 id="本书简介"><a href="#本书简介" class="headerlink" title="本书简介"></a>本书简介</h2><p>以下摘自豆瓣书评，可以大致了解这本书题材，读者评价等基本信息。</p>
<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/douban_qczl.png?imageView2/1/w/650/h/480/interlace/1/q/100" alt="倾城之恋 豆瓣"></p>
<p>在一位朋友的推荐下，第一次认真拜读张爱玲的著作，《倾城之恋》应该算她比较典型的作品之一了，文笔自不用说，没有华丽辞藻来修饰，而是朴实的将一个个角色的灵魂, 智慧, 善良, 包容, 炫耀, 做作，矫情，矜持等等心性暴露出来，果大师之作，就是能直击内心。</p>
<p>首先“倾城之恋”这个书名就非常好，在看之前我就想着主人公应该会有这倾国倾城的美貌吧，也有可能会很悲壮，像孟姜女哭倒长城一样，也算倾了城；后来看了才知道，这原来是一个自私的男人和一个自私的女人产生了真爱的故事，真爱的产生正是因为倾了城——香港的沦陷，书名由来可能也是于此；其实想想，不仅是在那个兵荒马乱的年代，就是当下，真爱依然难寻，试问真爱值几钱？再说下去，就是扯物质、精神、境界、人生观、价值观上了，其实扯来扯去，任何时代，相亲无非是男女在做天平的平衡匹配，各自抛出自己的一个个砝码，抛到最后，发现还是平衡的，这个事差不多就成了，年代不同，砝码的重量不一样而已。回到小说中的年代，上海仍然被殖民，具体年代我也不清楚；</p>
<p>范柳原，一个海外归来的浪子，生活的纸醉金迷，便把“女人看成他脚底下的泥”，爱情和婚姻原是他不相信，也不敢指望的。但他内心深处是渴望安稳的，对待女主也起初只是想养一个情妇而已。</p>
<p>白流苏，一个离过婚的女人，出身守旧的白家，白公馆的老钟在最开始就是一个交代，和男主交往也是只求一个完美的婚姻，一张长久的饭票。</p>
<p>就这样他们勾搭上了，各怀鬼胎，相互试探，这部分爱情攻防战是小说很精彩的部分，我估计如果是现实，剧情就在这里停止了，既然是小说，总要有个难忘的结局吧，所以炮火响起了，香港沦陷了，尔虞我诈的计较在失去一切之后发现身边仅有你我时，俩人傻子一样大笑起来，真爱也就滋生了，男主也认真的恋爱了，女主也心满意足了。</p>
<p>范柳原最后又说了一遍，“现在你可该相信了：‘死生契阔’，我们自己哪做得了主？……”，其实这里我觉得，不仅是“死生契阔”我们做不了主，就连爱情里的求全责备，权衡算计也是做不了主的。</p>
<hr>
<p>作者 <a href="https://github.com/naturezhm" target="_blank" rel="external">@Brady</a><br>2016年8月26日</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjsg3.com1.z0.glb.clouddn.com/github/qinchenzhilian.jpg&quot; alt=&quot;倾城之恋&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;没错，我不仅看书，还要开始写读后感了&quot;&gt;&lt;a href=&quot;#没错，我不仅看书
    
    </summary>
    
      <category term="读书" scheme="http://naturezhm.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="倾城之恋" scheme="http://naturezhm.github.io/categories/%E8%AF%BB%E4%B9%A6/%E5%80%BE%E5%9F%8E%E4%B9%8B%E6%81%8B/"/>
    
    
      <category term="读书" scheme="http://naturezhm.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="倾城之恋" scheme="http://naturezhm.github.io/tags/%E5%80%BE%E5%9F%8E%E4%B9%8B%E6%81%8B/"/>
    
      <category term="张爱玲" scheme="http://naturezhm.github.io/tags/%E5%BC%A0%E7%88%B1%E7%8E%B2/"/>
    
  </entry>
  
  <entry>
    <title>01.Spring整体架构</title>
    <link href="http://naturezhm.github.io/2016/08/10/01-Spring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://naturezhm.github.io/2016/08/10/01-Spring整体架构/</id>
    <published>2016-08-10T08:37:45.000Z</published>
    <updated>2016-08-30T03:02:13.213Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/spring-logo-min.png" alt="Spring Framework Logo"></p>
<hr>
<h2 id="开坑前言"><a href="#开坑前言" class="headerlink" title="开坑前言"></a>开坑前言</h2><p>作为一个开发者，阅读源码是一种非常好的学习方式，在我们日常工作或者学习中，或多或少会接触到一些开源代码，例如Java中的SSH, mybatis等，这些源码的普及和应用程度远远超过我们的想象，很多人也不断的推动和完善这些代码，有着多年积淀，不管我们当前是什么水平，阅读这些源码可以更加熟练使用，让我们程序设计更加完美，让我们思维方式更为开阔，纵观身边的朋友，能够通读源码的人确实不多，究其原因，<strong>无外乎</strong>：</p>
<ol>
<li>时间精力有限，不愿意开始着手；</li>
<li>复杂度太高了，面对庞大的环环相扣的源码体系，无从下手，无法驾驭；</li>
<li>耐心或者说毅力不够，以为自己能见微知著，殊不知却是盲人摸象。</li>
</ol>
<p>无论基于什么情况，放弃对源码的阅读始终难免留下遗憾，因为失去了和大师学习的机会，而且是自己亲手放弃的。开这个坑，也是计划通过博客记录，做出经验沉淀，不为传授，只为记录，在开始阅读时，我选择了几本书作为辅助工具，辅佐我作为一个源码阅读的入口，因为面对好几个MB的源码，我也照样无从下手。</p>
<h2 id="1-Spring的整体架构"><a href="#1-Spring的整体架构" class="headerlink" title="1 Spring的整体架构"></a>1 Spring的整体架构</h2><p>如下图所示，spring框架包含很多功能集合，约20个模块<br><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/spring-overview.png" alt="Spring Framework overview"><br>这些模块分别为：</p>
<h4 id="1-Core-container"><a href="#1-Core-container" class="headerlink" title="(1) Core container"></a>(1) Core container</h4><p>核心容器，包括了Core, Beans, Context和Expression Language模块。</p>
<blockquote>
<p>Core和Beans模块是框架的基础部分，提供了Ioc和DI特性，这里的基础概念是BeanFactory，他提供对Factory模式的实现来消除程序单例模式的需要，并真正的让程序逻辑中分离出依赖关系和配置。</p>
</blockquote>
<ul>
<li>Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件都要使用这个包；</li>
<li>Beans模块是所有应用都要用到的，包含访问配置文件、创建和管理bean以及进行IoC/DI操作相关的类。</li>
<li>Context模块构建与Core与Beans之上，提供了一种类似与JNDI注册器的框架式对象访问方法，Context继承Beans特性，为Spring核心提供了大量的扩展，添加了对国际化、事件传播、资源加载核对Context的透明创建支持，支持J2EE的一些特性，EJB,JMX和基础的远程处理，其中ApplicationContext是Context模块的关键。</li>
<li>Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操作对象，扩展了JSP expression language。</li>
</ul>
<h4 id="2-Data-access-Integration"><a href="#2-Data-access-Integration" class="headerlink" title="(2) Data access/Integration"></a>(2) Data access/Integration</h4><p>Data access/Integration层包含了JDBC、ORM、OXM、JMS和Transation模块，其中：</p>
<ul>
<li>JDBC模块提供了一个JDBC抽象层，对各类数据库进行了封装；</li>
<li>ORM模块熟悉的有Hibernate、Mybatis提供了一个数据访问层。</li>
<li>OXM框架提供了一个对Object/XML映射实现的抽象层，Object/XML映射实现包括JAXB、Castor、XMLBeans、JiBx、Xstream。（其实我觉得Object/Json方式比OXM更好）</li>
<li>JMS主要包含了一些制造和消费消息的特性；</li>
<li>Transation模块支持编程和声明性事物的管理，这些事物类必须实现特定的接口，并且对所有的POJO都使用。</li>
</ul>
<h4 id="3-Web"><a href="#3-Web" class="headerlink" title="(3) Web"></a>(3) Web</h4><p>Web模块是简历在Servlet程序模块之上，Spring兹慈与其他文本框架Struts的集成，Web模块还简化了处理多中请求及参数绑定的工作；好汉了Web、Web-Servlet、Web-struts和Web-Prolet模块，具体说明如下：</p>
<ul>
<li>Web模块：提供了基础的面向Web的集成特性，例如，多文件上传，使用servlet listeners初始化Ioc容器以及一个面向web的应用上下文；</li>
<li>Web-Servlet模块：该模块包含Spring的MVC实现，使得模型范围内的代码和web form之间能够清晰的分开并能与Spring框架的其他特性集成在一起；</li>
<li>Web-Struts模块：提供了对struts的兹慈，但是在3.0后已经deprecated了。</li>
<li>Web-Porlet模块：提供了Porlet环境和Web-Servlet模块的MVC实现（在需要写Porlet应用时可以直接用这个模块，不过在如今各类webservice当道的情况下，RSS都比较少见了，貌似一般不会选型这个）。</li>
</ul>
<h4 id="4-AOP"><a href="#4-AOP" class="headerlink" title="(4) AOP"></a>(4) AOP</h4><p>AOP模块提供了一个符合标准的面向切面编程实现，可以降低耦合性，利用Source-level的注解机制（元数据功能），还可以讲各种行为信息整合到代码里，类似.net中的attribute（不是parameter）；Spring AOP提供了事物管理服务，</p>
<h4 id="5-Test"><a href="#5-Test" class="headerlink" title="(5) Test"></a>(5) Test</h4><p>Test模块支持各种测试框架。</p>
<hr>
<p>作者 <a href="https://github.com/naturezhm" target="_blank" rel="external">@Brady</a><br>2016年8月10日</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjsg3.com1.z0.glb.clouddn.com/github/spring-logo-min.png&quot; alt=&quot;Spring Framework Logo&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;开坑前言&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="框架" scheme="http://naturezhm.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring源码学习" scheme="http://naturezhm.github.io/categories/%E6%A1%86%E6%9E%B6/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="分布式" scheme="http://naturezhm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Spring源码" scheme="http://naturezhm.github.io/tags/Spring%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ZMQ详细安装文档</title>
    <link href="http://naturezhm.github.io/2016/07/16/ZMQ%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/"/>
    <id>http://naturezhm.github.io/2016/07/16/ZMQ详细安装文档/</id>
    <published>2016-07-16T08:23:39.000Z</published>
    <updated>2016-08-26T10:07:43.839Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/zmq.gif?imageView2/1/w/650/h/370/interlace/1/q/100" alt="ZMQ Logo"></p>
<hr>
<h2 id="1-JDK安装"><a href="#1-JDK安装" class="headerlink" title="1.  JDK安装"></a>1.  JDK安装</h2><p>我安装的是java version “1.8.0_73”<br><code>注意： 要配置好classpath，检测方法为</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###如果结果如下，表示配置成功</span></div><div class="line">[root@server001 java]<span class="comment"># java -version</span></div><div class="line">java version <span class="string">"1.8.0_73"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_73-b02)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)</div><div class="line">[root@server001 java]<span class="comment"># javac -version</span></div><div class="line">javac 1.8.0_73</div></pre></td></tr></table></figure></p>
<h2 id="2-官网下载zeromq的源码"><a href="#2-官网下载zeromq的源码" class="headerlink" title="2. 官网下载zeromq的源码"></a>2. 官网下载zeromq的源码</h2><p><a href="https://github.com/zeromq/zeromq4-1/releases/download/v4.1.5/zeromq-4.1.5.tar.gz" target="_blank" rel="external">https://github.com/zeromq/zeromq4-1/releases/download/v4.1.5/zeromq-4.1.5.tar.gz</a><br>或者我共享的<a href="http://git.oschina.net/naturezhm/ZhmShare/raw/master/zeromq-4.1.5.tar.gz" target="_blank" rel="external">zip压缩包@gitoschina</a></p>
<h2 id="3-解压，编译安装zeromqs"><a href="#3-解压，编译安装zeromqs" class="headerlink" title="3. 解压，编译安装zeromqs"></a>3. 解压，编译安装zeromqs</h2><blockquote>
<p>检查环境</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install autoconf automake libtool gcc gcc-g++ make libuuid-dev git</div></pre></td></tr></table></figure>
<blockquote>
<p>安装指令如下(make install 指令需要<code>root</code>权限)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tar -xzf  zeromq-4.1.5.tar.gz </div><div class="line"><span class="built_in">cd</span> zeromq-4.1.5</div><div class="line">./autogen.sh</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div><div class="line">ldconfig</div><div class="line"><span class="comment">## 安装完成后，如果没报错，ls /usr/local/lib 会发现有文件名为libzmq的文件表示安装成功</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="4-下载JZMQ"><a href="#4-下载JZMQ" class="headerlink" title="4. 下载JZMQ"></a>4. 下载JZMQ</h2><p>JZMQ是java封装了一下ZMQ，不是另外一个<a href="https://github.com/zeromq/jeromq" target="_blank" rel="external">Pure Java ZeroMQ</a>，下载地址为<br><a href="https://github.com/zeromq/jzmq.git，用git" target="_blank" rel="external">https://github.com/zeromq/jzmq.git，用git</a> clone下来<br>或者下载<a href="https://github.com/zeromq/jzmq/archive/master.zip" target="_blank" rel="external">zip压缩包@github</a>或者我共享的<a href="http://git.oschina.net/naturezhm/ZhmShare/raw/master/jzmq-master.zip" target="_blank" rel="external">zip压缩包@gitoschina</a></p>
<p><code>不要下载v3.1.0  release版本，这个无法编译，是坑</code></p>
<h2 id="5-解压编译安装JZMQ"><a href="#5-解压编译安装JZMQ" class="headerlink" title="5. 解压编译安装JZMQ"></a>5. 解压编译安装JZMQ</h2><blockquote>
<p>安装指令如下(make install指令需要<code>root</code>权限)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">unzip jzmq-master.zip</div><div class="line"><span class="built_in">cd</span> jzmq-jni/</div><div class="line">./autogen.sh</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div><div class="line"><span class="comment">### cd ..</span></div><div class="line"><span class="comment">### mvn package 官网有这个步骤，但是别按着来，是坑</span></div></pre></td></tr></table></figure></p>
<p>安装完成后检查，如果都符合，恭喜，很有可能安装成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### lib下有如下包</span></div><div class="line">[root@server001 java]<span class="comment"># ls /usr/local/lib</span></div><div class="line">libjzmq.a   libjzmq.so.0      libpcre2-8.la    libpcre2-8.so.0.3.0  libpcre2-posix.so        libz.a     libzmq.so        libz.so        pkgconfig</div><div class="line">libjzmq.la  libjzmq.so.0.0.0  libpcre2-8.so    libpcre2-posix.a     libpcre2-posix.so.0      libzmq.a   libzmq.so.5      libz.so.1</div><div class="line">libjzmq.so  libpcre2-8.a      libpcre2-8.so.0  libpcre2-posix.la    libpcre2-posix.so.0.0.1  libzmq.la  libzmq.so.5.0.1  libz.so.1.2.8</div><div class="line"></div><div class="line"><span class="comment">#### 有jar包在此目录</span></div><div class="line">[root@server001 lib]<span class="comment"># ls /usr/local/share/java/</span></div><div class="line">zmq.jar</div></pre></td></tr></table></figure></p>
<p>设置环境变量（root权限）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi /etc/bashrc</div><div class="line">vi /etc/profile</div><div class="line"><span class="comment">### 底部添加如下内容</span></div><div class="line">LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/lib</div><div class="line"><span class="built_in">export</span> LD_LIBRARY_PATH</div><div class="line">CLASSPATH=.:<span class="variable">$CLASSPATH</span>:/usr/<span class="built_in">local</span>/share/java/zmq.jar</div><div class="line"><span class="built_in">export</span> CLASSPATH</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="6-写server和client代码验证JZMQ安装成功"><a href="#6-写server和client代码验证JZMQ安装成功" class="headerlink" title="6. 写server和client代码验证JZMQ安装成功"></a>6. 写server和client代码验证JZMQ安装成功</h2><p>这里是官方的Guide文档（很长，有多种语言的实现，我们只选择Java）<a href="http://zguide.zeromq.org/page:all" target="_blank" rel="external">http://zguide.zeromq.org/page:all</a><br>你也可以看我写的代码进行测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">### 运行成功输出</span></div><div class="line">[root@server001 java]<span class="comment"># java -jar server.jar </span></div><div class="line">Received Hello</div><div class="line">Received Hello</div><div class="line">Received Hello</div><div class="line">Received Hello</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[root@server001 java]<span class="comment"># java -jar client.jar </span></div><div class="line">Connecting to hello world server…</div><div class="line">Sending Hello 0</div><div class="line">Received World 0</div><div class="line">Sending Hello 1</div><div class="line">Received World 1</div><div class="line">Sending Hello 2</div><div class="line">Received World 2</div><div class="line">...</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 以下是测试Java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.zeromq.ZMQ;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by admin on 2016/7/15.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hwserver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ZMQ.Context context = ZMQ.context(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//  Socket to talk to clients</span></div><div class="line">        ZMQ.Socket responder = context.socket(ZMQ.REP);</div><div class="line">        responder.bind(<span class="string">"tcp://*:5555"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">            <span class="comment">// Wait for next request from the client</span></div><div class="line">            <span class="keyword">byte</span>[] request = responder.recv(<span class="number">0</span>);</div><div class="line">            System.out.println(<span class="string">"Received Hello"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// Do some 'work'</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line"></div><div class="line">            <span class="comment">// Send reply back to client</span></div><div class="line">            String reply = <span class="string">"World"</span>;</div><div class="line">            responder.send(reply.getBytes(), <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        responder.close();</div><div class="line">        context.term();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.zeromq.ZMQ;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by admin on 2016/7/15.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hwclient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ZMQ.Context context = ZMQ.context(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//  Socket to talk to server</span></div><div class="line">        System.out.println(<span class="string">"Connecting to hello world server…"</span>);</div><div class="line"></div><div class="line">        ZMQ.Socket requester = context.socket(ZMQ.REQ);</div><div class="line">        requester.connect(<span class="string">"tcp://localhost:5555"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> requestNbr = <span class="number">0</span>; requestNbr != <span class="number">10</span>; requestNbr++) &#123;</div><div class="line">            String request = <span class="string">"Hello"</span>;</div><div class="line">            System.out.println(<span class="string">"Sending Hello "</span> + requestNbr);</div><div class="line">            requester.send(request.getBytes(), <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">byte</span>[] reply = requester.recv(<span class="number">0</span>);</div><div class="line">            System.out.println(<span class="string">"Received "</span> + <span class="keyword">new</span> String(reply) + <span class="string">" "</span> + requestNbr);</div><div class="line">        &#125;</div><div class="line">        requester.close();</div><div class="line">        context.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjsg3.com1.z0.glb.clouddn.com/github/zmq.gif?imageView2/1/w/650/h/370/interlace/1/q/100&quot; alt=&quot;ZMQ Logo&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 i
    
    </summary>
    
      <category term="编程" scheme="http://naturezhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="消息队列" scheme="http://naturezhm.github.io/categories/%E7%BC%96%E7%A8%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="分布式" scheme="http://naturezhm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="消息队列" scheme="http://naturezhm.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="JZMQ" scheme="http://naturezhm.github.io/tags/JZMQ/"/>
    
      <category term="ZMQ" scheme="http://naturezhm.github.io/tags/ZMQ/"/>
    
  </entry>
  
  <entry>
    <title>双端队列(deque)</title>
    <link href="http://naturezhm.github.io/2013/04/17/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-deque/"/>
    <id>http://naturezhm.github.io/2013/04/17/双端队列-deque/</id>
    <published>2013-04-17T03:49:19.000Z</published>
    <updated>2016-08-26T08:33:45.256Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/github/20160417123735.png?imageView2/1/w/650/h/370/interlace/1/q/100" alt=""></p>
<p> <code>这一篇是很久前第一次写的，其实不算原创，抄了其他人的博客，不过都特别说明了</code></p>
<hr>
<p>暑假，今天看到双端队列(deque)了，书上是这样说的：</p>
<blockquote>
<p>除了栈和队列外还有一种限定性数据结构是双端队列；双端队列是限定插入和删除操作在表的两端进行的线性表；尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，故在此不作详细讨论。</p>
</blockquote>
<p>于是乎就跳了过去讲链队列和循环队列去了，我想反正是复习嘛，没有考试的压力，不要放过就是了，再说就算双端队列远不及栈和队列有用，也要知道怎么个没用法。所以就查了下:</p>
<blockquote>
<p>Deque成员函数</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述   </th>
</tr>
</thead>
<tbody>
<tr>
<td>c.assign(n,elem)</td>
<td>将n个elem的拷贝赋值给c。    </td>
</tr>
<tr>
<td>c.at(idx)</td>
<td>传回索引idx所指的数据，如果idx越界，抛出out_of_range。    </td>
</tr>
<tr>
<td>c.back()</td>
<td>传回最后一个数据，不检查这个数据是否存在。    </td>
</tr>
<tr>
<td>c.begin()</td>
<td>传回迭代器重的可一个数据。    </td>
</tr>
<tr>
<td>c.clear()</td>
<td>移除容器中所有数据。    </td>
</tr>
<tr>
<td>deque<elem> c</elem></td>
<td>创建一个空的deque。    </td>
</tr>
<tr>
<td>deque<elem> c1(c2)</elem></td>
<td>复制一个deque。    </td>
</tr>
<tr>
<td>Deque<elem> c(n)</elem></td>
<td>创建一个deque，含有n个数据，数据均已缺省构造产生。    </td>
</tr>
<tr>
<td>Deque<elem> c(n, elem)</elem></td>
<td>创建一个含有n个elem拷贝的deque。    </td>
</tr>
<tr>
<td>Deque<elem> c(beg,end)</elem></td>
<td>创建一个以[beg;end)区间的deque。    </td>
</tr>
<tr>
<td>c.~deque<elem>()</elem></td>
<td>销毁所有数据，释放内存。    </td>
</tr>
<tr>
<td>c.empty()</td>
<td>判断容器是否为空。    </td>
</tr>
<tr>
<td>c.end()</td>
<td>指向迭代器中的最后一个数据地址。    </td>
</tr>
<tr>
<td>c.erase(pos)</td>
<td>删除pos位置的数据，传回下一个数据的位置。    </td>
</tr>
<tr>
<td>c.erase(beg,end)</td>
<td>删除[beg,end)区间的数据，传回下一个数据的位置。    </td>
</tr>
<tr>
<td>c.front()</td>
<td>传回地一个数据。    </td>
</tr>
<tr>
<td>get_allocator</td>
<td>使用构造函数返回一个拷贝。    </td>
</tr>
<tr>
<td>c.insert(pos,elem)</td>
<td>在pos位置插入一个elem拷贝，传回新数据位置。    </td>
</tr>
<tr>
<td>c.insert(pos,n,elem)</td>
<td>在pos位置插入&gt;n个elem数据。无返回值。    </td>
</tr>
<tr>
<td>c.insert(pos,beg,end)</td>
<td>在pos位置插入在[beg,end)区间的数据。无返回值。    </td>
</tr>
<tr>
<td>c.max_size()</td>
<td>返回容器中最大数据的数量。    </td>
</tr>
<tr>
<td>c.pop_back()</td>
<td>删除最后一个数据。    </td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除头部数据。    </td>
</tr>
<tr>
<td>c.push_back(elem)</td>
<td>在尾部加入一个数据。    </td>
</tr>
<tr>
<td>c.push_front(elem)</td>
<td>在头部插入一个数据。    </td>
</tr>
<tr>
<td>c.rbegin()</td>
<td>传回一个逆向队列的第一个数据。    </td>
</tr>
<tr>
<td>c.rend()</td>
<td>传回一个逆向队列的最后一个数据的下一个位置。    </td>
</tr>
<tr>
<td>c.resize(num)</td>
<td>重新指定队列的长度。    </td>
</tr>
<tr>
<td>c.size()</td>
<td>返回容器中实际数据的个数。    </td>
</tr>
<tr>
<td>C1.swap(c2)</td>
<td>将c1和c2元素互换。    </td>
</tr>
<tr>
<td>Swap(c1,c2)</td>
<td>同上操作。    </td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中指定位置的一个引用。    </td>
</tr>
</tbody>
</table>
<p>又搜到了一个<a href="http://hi.baidu.com/xuehuo_0411/blog/item/c225942c0a02033a349bf7d1.html" target="_blank" rel="external">使用C++ STL容器基本操作的博客</a> ，后我照着一些简单的程序写了遍，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">双端队列容器(<span class="built_in">deque</span>)</div><div class="line"><span class="comment">/*</span></div><div class="line">2011.7.24</div><div class="line">使用c++ STL库的双端队列容器(deque)的小程序</div><div class="line">看了博客 http://hi.baidu.com/xuehuo_0411/blog/item/c225942c0a02033a349bf7d1.html 后照着写的</div><div class="line">msdn的文档是 http://msdn.microsoft.com/zh-cn/library/bb398188.aspx</div><div class="line">其中还有些没有写了，其他重要函数</div><div class="line">d1.swap(d2);//d1和d2交换</div><div class="line">zm.max_size();//可支持的最大deque元素个数</div><div class="line">zm.front();//首元素</div><div class="line">zm.back();//末元素</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">viewByArrey</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm)</span></span>;<span class="comment">//用数组的方式访问deque元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">viewByIterator</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm)</span></span>;<span class="comment">//用迭代器的方式來訪問deque元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertFrontAndCenter</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm)</span></span>; <span class="comment">//头部和中间位置插入deque元素</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </div><div class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm;</div><div class="line">    <span class="comment">//viewByArrey(zm);</span></div><div class="line">    <span class="comment">//viewByIterator(zm);</span></div><div class="line">    insertFrontAndCenter(zm);<span class="comment">//头部和中间位置插入deque元素</span></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">viewByArrey</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm)</span></span>&#123;<span class="comment">//用数组的方式访问deque元素</span></div><div class="line">    zm.push_back(<span class="number">26</span>);</div><div class="line">    zm.push_back(<span class="number">11</span>);</div><div class="line">    zm.push_back(<span class="number">12</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zm.size();i++)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;zm[i]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">viewByIterator</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm)</span></span>&#123;</div><div class="line">    zm.push_back(<span class="number">111</span>);</div><div class="line">    zm.push_back(<span class="number">222</span>);</div><div class="line">    zm.push_back(<span class="number">333</span>);</div><div class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator aa;<span class="comment">//定义了迭代器aa</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(aa = zm.begin(),i = <span class="number">0</span>;aa != zm.end();aa++,i++)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;aa[<span class="number">0</span>]&lt;&lt;<span class="string">"\t"</span>&lt;&lt;*aa&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="comment">//cout&lt;&lt;*aa&lt;&lt;endl;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertFrontAndCenter</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; zm)</span></span>&#123;<span class="comment">//头部和中间位置插入deque元素</span></div><div class="line">    zm.push_back(<span class="number">111</span>);</div><div class="line">    zm.push_back(<span class="number">222</span>);</div><div class="line">    zm.push_front(<span class="number">333</span>);<span class="comment">//放到前面</span></div><div class="line">    zm.insert(zm.begin()+<span class="number">2</span>,<span class="number">444</span>);<span class="comment">//理论上是放到111后面</span></div><div class="line">    <span class="comment">//看是不是这个顺序333,111,444,222</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zm.size();i++)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;zm[i]&lt;&lt;<span class="string">","</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>写完之后，觉得deque还是很好用的啊，就查了下“C++ STL deque的缺点”，<a href="http://blog.csdn.net/ianleelj/article/details/3939354" target="_blank" rel="external">觉得这人讲的不错，还做了对比</a>，内容不多就贴下吧，</p>
<h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1 vector"></a>1 vector</h3><pre><code>向量 相当于一个数组
在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。
</code></pre><p>   <strong>优点</strong>：</p>
<ol>
<li>不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()<ol>
<li>随机访问方便，即支持[ ]操作符和vector.at()</li>
<li>节省空间。<br><strong>缺点</strong>：</li>
<li>在内部进行插入删除操作效率低。</li>
<li>只能在vector的最后进行push和pop，不能在vector的头进行push和pop。</li>
<li>当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放 </li>
</ol>
</li>
</ol>
<hr>
<h3 id="2-list"><a href="#2-list" class="headerlink" title="2 list"></a>2 list</h3><pre><code>双向链表
每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。
</code></pre><p>   <strong>优点</strong>：</p>
<ol>
<li>不使用连续内存完成动态操作。</li>
<li>在内部方便的进行插入和删除操作</li>
<li><p>可在两端进行push、pop</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>不能进行内部的随机访问，即不支持[ ]操作符和vector.at()</li>
<li>相对于verctor占用内存多</li>
</ol>
</li>
</ol>
<hr>
<h3 id="3-deque"><a href="#3-deque" class="headerlink" title="3 deque"></a>3 deque</h3><p>   双端队列 double-end queue<br>   deque是在功能上合并了vector和list。<br>   优点：</p>
<ol>
<li>随机访问方便，即支持[ ]操作符和vector.at()</li>
<li>在内部方便的进行插入和删除操作               </li>
<li><p>可在两端进行push、pop</p>
<p>缺点：</p>
</li>
<li>占用内存多</li>
</ol>
<p>使用区别：</p>
<ol>
<li>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector </li>
<li>如果你需要大量的插入和删除，而不关心随即存取，则应使用list </li>
<li>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</li>
</ol>
<p>看了后觉得deque还是很好用的嘛，虽然内存占用多些，但是也不至于像书上那样说的一无是处，deque像是集vector和list两者特性的一个容器，牺牲内存换的功能的完善也没什么不可以吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjsg3.com1.z0.glb.clouddn.com/github/20160417123735.png?imageView2/1/w/650/h/370/interlace/1/q/100&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;co
    
    </summary>
    
      <category term="编程" scheme="http://naturezhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://naturezhm.github.io/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://naturezhm.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="测试" scheme="http://naturezhm.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://naturezhm.github.io/2013/04/01/hello-world/"/>
    <id>http://naturezhm.github.io/2013/04/01/hello-world/</id>
    <published>2013-04-01T03:49:19.000Z</published>
    <updated>2016-08-26T08:34:11.536Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjsg3.com1.z0.glb.clouddn.com/gihub/blogHello-World-background.png?imageView2/0/w/1060/h/661/interlace/1/q/100" alt="enter image description here"></p>
<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjsg3.com1.z0.glb.clouddn.com/gihub/blogHello-World-background.png?imageView2/0/w/1060/h/661/interlace/1/q/100&quot; alt=&quot;en
    
    </summary>
    
    
  </entry>
  
</feed>
